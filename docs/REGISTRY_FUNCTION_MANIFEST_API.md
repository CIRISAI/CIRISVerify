# Registry API Requirements for Function Manifests (v0.5.5)

This document describes the new API endpoints that CIRISRegistry needs to implement to support function-level integrity verification in CIRISVerify v0.5.5.

## Overview

Function manifests provide fine-grained integrity verification at the function level. At runtime, CIRISVerify can verify that each critical function (FFI exports) hasn't been modified since the manifest was generated.

## New Endpoints Required

### 1. Upload Function Manifest

**Endpoint:** `POST /v1/verify/function-manifest`

**Authentication:** `REGISTRY_ADMIN_TOKEN`

**Request Body:**
```json
{
  "version": "1.0.0",
  "target": "x86_64-unknown-linux-gnu",
  "binary_hash": "sha256:c7049adb0f4b7bc75d5ca6c6bfdc22552fd03c3d39f429863e589331e4b4a26a",
  "binary_version": "0.5.4",
  "generated_at": "2026-02-21T02:51:03.842898877+00:00",
  "functions": {
    "ciris_verify_init": {
      "name": "ciris_verify_init",
      "offset": 2401440,
      "size": 22297,
      "hash": "sha256:ee6f129c36169b5dfd7a9b1158dd15c7eb0aa9011b3d88f9f08540d9d0a7ed50"
    },
    "ciris_verify_get_status": {
      "name": "ciris_verify_get_status",
      "offset": 2383440,
      "size": 15176,
      "hash": "sha256:d6f9d2d1b71a8e42bd611b6ca1422bf58447b567fb341658d4280c47442c9c5b"
    }
    // ... other functions
  },
  "manifest_hash": "sha256:54b973946e34b19452fec6220f96701be1800fb13f18c10e7c5801bd7bf88eb5",
  "signature": {
    "classical": "base64...",
    "classical_algorithm": "Ed25519",
    "pqc": "base64...",
    "pqc_algorithm": "ML-DSA-65",
    "key_id": "steward-2026"
  }
}
```

**Response:** `201 Created`

### 2. Get Function Manifest

**Endpoint:** `GET /v1/verify/function-manifest/{version}/{target}`

**Example:** `GET /v1/verify/function-manifest/0.5.4/x86_64-unknown-linux-gnu`

**Response:**
```json
{
  "version": "1.0.0",
  "target": "x86_64-unknown-linux-gnu",
  "binary_hash": "sha256:...",
  "binary_version": "0.5.4",
  "generated_at": "2026-02-21T02:51:03Z",
  "functions": { ... },
  "manifest_hash": "sha256:...",
  "signature": { ... }
}
```

### 3. List Available Function Manifests

**Endpoint:** `GET /v1/verify/function-manifests/{version}`

**Response:**
```json
{
  "version": "0.5.4",
  "targets": [
    "x86_64-unknown-linux-gnu",
    "aarch64-unknown-linux-gnu",
    "x86_64-apple-darwin",
    "aarch64-apple-darwin",
    "x86_64-pc-windows-msvc",
    "aarch64-linux-android"
  ]
}
```

## Target Triples

The following targets will have function manifests generated by CI:

| Target Triple | Platform | Binary Format |
|--------------|----------|---------------|
| `x86_64-unknown-linux-gnu` | Linux x86_64 | ELF |
| `aarch64-unknown-linux-gnu` | Linux ARM64 | ELF |
| `x86_64-apple-darwin` | macOS Intel | Mach-O |
| `aarch64-apple-darwin` | macOS Apple Silicon | Mach-O |
| `x86_64-pc-windows-msvc` | Windows x86_64 | PE |
| `aarch64-linux-android` | Android ARM64 | ELF |
| `aarch64-apple-ios` | iOS ARM64 | Mach-O |

## Manifest Signing

The CI pipeline will sign manifests using the steward key:

1. **Classical Signature (Ed25519):** Signs the canonical manifest JSON (excluding signature fields)
2. **PQC Signature (ML-DSA-65):** Signs `canonical_manifest || classical_signature` (bound signature)

Both signatures must verify for the manifest to be trusted.

## CI Integration

The release workflow will be updated to:

1. Build binaries for all targets
2. Run `ciris-manifest-tool generate` for each binary
3. Sign manifests with steward key
4. Upload to registry via `POST /v1/verify/function-manifest`

Example CI step:
```yaml
- name: Generate and upload function manifests
  run: |
    for binary in artifacts/*.so artifacts/*.dylib artifacts/*.dll; do
      target=$(./ciris-manifest-tool detect-target --binary "$binary")
      ./ciris-manifest-tool generate \
        --binary "$binary" \
        --target "$target" \
        --version ${{ github.ref_name }} \
        --output "manifest-${target}.json"

      # Sign and upload (signing handled by separate tool)
      curl -X POST \
        -H "Authorization: Bearer ${{ secrets.REGISTRY_ADMIN_TOKEN }}" \
        -H "Content-Type: application/json" \
        -d @"manifest-${target}.json" \
        "https://api.registry.ciris-services-1.ai/v1/verify/function-manifest"
    done
```

## Database Schema Suggestion

```sql
CREATE TABLE function_manifests (
    id SERIAL PRIMARY KEY,
    binary_version VARCHAR(32) NOT NULL,
    target VARCHAR(64) NOT NULL,
    manifest_json JSONB NOT NULL,
    manifest_hash VARCHAR(128) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(binary_version, target)
);

CREATE INDEX idx_function_manifests_version ON function_manifests(binary_version);
CREATE INDEX idx_function_manifests_target ON function_manifests(target);
```

## Security Considerations

- Manifests are signed with the steward key - verify signature before serving
- Each target has a unique manifest (different offsets, hashes)
- Manifests should be immutable once uploaded for a given version+target
- Consider adding manifest revocation for compromised releases

## Timeline

- **v0.5.5:** Manifest generation tool complete, CI integration ready
- **Registry:** Implement endpoints before v0.5.5 release
- **v0.6.0:** Runtime verification enabled (constructor-based)
